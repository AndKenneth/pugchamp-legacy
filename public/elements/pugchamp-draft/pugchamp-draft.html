<link rel="import" href="/components/polymer/polymer.html">

<link rel="import" href="/components/paper-material/paper-material.html">
<link rel="import" href="/components/paper-progress/paper-progress.html">
<link rel="import" href="/components/paper-radio-button/paper-radio-button.html">

<link rel="import" href="/elements/pugchamp-client/pugchamp-client-base-behavior.html">
<link rel="import" href="/elements/pugchamp-client/pugchamp-client-restrictions-behavior.html">
<link rel="import" href="/elements/pugchamp-client/pugchamp-client-user-behavior.html">
<link rel="import" href="/elements/pugchamp-utilities/pugchamp-polymer-helpers.html">

<dom-module id="pugchamp-draft">
    <template>
        <style is="custom-style">
            #draftTurns {
                padding: 5px;
            }

            .draft-turn {
                @apply(--paper-font-caption);

                padding: 5px;
                text-align: center;
            }

            .draft-turn .turn-time {
                width: 100%;
                --paper-progress-height: 12px;
            }

            .draft-turn[data-status=completed] {
                background: var(--google-grey-300);
                opacity: 0.5;
            }

            .draft-turn[data-status=current] {
                background: var(--google-green-300);
            }

            .map {
                margin: 5px;
                text-align: center;
            }

            .map .map-overlay {
                bottom: 0;
                height: 100%;
                left: 0;
                position: absolute;
                right: 0;
                top: 0;
                width: 100%;
            }

            .map .map-overlay[data-status=banned] {
                background: var(--google-red-300);
                opacity: 0.5;
            }

            .map .map-overlay[data-status=picked] {
                background: var(--google-green-300);
                opacity: 0.5;
            }

            .map .map-background {
                width: 100%;
            }
        </style>

        <div hidden$="{{!draftInProgress}}">
            <div id="draftTurns" class="horizontal layout">
                <template is="dom-repeat" items="{{turns}}">
                    <paper-material data-status$="{{turnComparison(index, currentTurn)}}" class="draft-turn flex">
                        <strong>{{fullTurnTypeDescription(item.type)}}</strong>
                        <br>
                        {{fullTurnMethodDescription(item.method)}}
                        <br>
                        {{fullTurnCaptainName(item.captain)}}
                        <br>
                        <paper-progress hidden$="{{!isCurrentTurn(index, currentTurn)}}" class="turn-time" class="transiting" min="0"></paper-progress>
                        {{fullTurnChoiceInfo(item)}}
                    </paper-material>
                </template>
            </div>
            <div id="maps" class="horizontal layout">
                <template is="dom-repeat" items="{{_convertObjectToRepeatable(maps)}}">
                    <paper-material class="map flex">
                        <div data-status$="{{mapStatus(item.key, pickedMaps, remainingMaps)}}" class="map-overlay"></div>
                        <img class="map-background" src$="{{mapImageBackground(item.value.image)}}">
                        <div class="map-info">
                            {{item.value.name}}
                            <p hidden$="{{!mapChoiceAllowed(user, currentTurn, item.key, remainingMaps)}}"><paper-radio-button name="map" value="{{item.key}}" disabled="{{!mapChoiceAllowed(user, currentTurn, item.key, remainingMaps)}}"></paper-radio-button></p>
                        </div>
                    </paper-material>
                </template>
            </div>
        </div>
    </template>

    <script>
        Polymer({
            is: 'pugchamp-draft',
            behaviors: [PugChampPolymerHelperBehaviors, PugChampClientBehaviors.BaseBehavior, PugChampClientBehaviors.RestrictionsBehavior, PugChampClientBehaviors.UserBehavior],
            ready: function() {
                this.set('draftInProgress', false);

                this._listenToEvent('draftStatusUpdated', 'onDraftStatusUpdated');
                this._listenToEvent('draftTurnTime', 'onDraftTurnTime');
            },
            onDraftStatusUpdated: function(status) {
                if (!status) {
                    this.set('draftInProgress', false);
                    return;
                }

                this.set('draftInProgress', true);

                this.set('roles', status.roles);
                this.set('maps', status.mapPool);
                this.set('turns', status.draftTurns);
                this.set('currentTurn', status.currentDraftTurn);
                this.set('captains', status.draftCaptains);
                this.set('pickedMaps', status.pickedMaps);
                this.set('remainingMaps', status.remainingMaps);
            },
            onDraftTurnTime: function(status) {
                if (this.currentTimer) {
                    this.cancelAsync(this.currentTimer);
                }

                this.async(function() {
                    var progress = Polymer.dom(this.$.draftTurns).querySelector('.draft-turn[data-status=current] .turn-time');
                    progress.value = status.elapsed / 1000;
                    progress.max = status.total / 1000;

                    this.currentTimer = this.async(this.incrementTurnTimer, 1000);
                });
            },
            incrementTurnTimer: function() {
                var progress = Polymer.dom(this.$.draftTurns).querySelector('.draft-turn[data-status=current] .turn-time');
                progress.value++;

                if (progress.ratio < 100) {
                    this.currentTimer = this.async(this.incrementTurnTimer, 1000);
                }
            },
            isCurrentTurn: function(turn, current) {
                return turn === current;
            },
            turnComparison: function(turn, current) {
                if (turn < current) {
                    return 'completed';
                }
                else if (turn === current) {
                    return 'current';
                }
                else if (turn > current) {
                    return 'upcoming';
                }
            },
            fullTurnTypeDescription: function(type) {
                if (type === 'playerPick') {
                    return 'Player Pick';
                }
                else if (type === 'captainRole') {
                    return 'Captain Role';
                }
                else if (type === 'mapBan') {
                    return 'Map Ban';
                }
                else if (type === 'mapPick') {
                    return 'Map Pick';
                }
            },
            fullTurnMethodDescription: function(method) {
                if (method === 'manual') {
                    return 'Choice';
                }
                else if (method === 'random') {
                    return 'Random';
                }
            },
            fullTurnCaptainName: function(captain) {
                if (captain) {
                    return this.captains[captain - 1].alias;
                }
            },
            fullTurnChoiceInfo: function(choice) {
                if (choice.type === 'playerPick') {
                    if (choice.player) {
                        return choice.player.alias + ' (' + this.roles[choice.role].name + ')';
                    }
                }
                else if (choice.type === 'captainRole') {
                    if (choice.role) {
                        return this.roles[choice.role].name;
                    }
                }
                else if (choice.type === 'mapBan' || choice.type === 'mapPick') {
                    if (choice.map) {
                        return this.maps[choice.map].name;
                    }
                }
            },
            mapImageBackground: function(image) {
                if (image) {
                    return '/assets/maps/' + image;
                }
            },
            mapStatus: function(map, picked, remaining) {
                if (picked.includes(map)) {
                    return 'picked';
                }

                if (!remaining.includes(map)) {
                    return 'banned';
                }

                return 'undecided';
            },
            mapChoiceAllowed: function(user, turn, map, remainingMaps) {
                if (this.turns[turn].type !== 'mapBan' && this.turns[turn].type !== 'mapPick') {
                    return false;
                }

                if (this.turns[turn].method !== 'manual') {
                    return false;
                }

                if (!this.user || this.user.steamID !== this.captains[this.turns[turn].captain - 1].steamID) {
                    return false;
                }

                if (!remainingMaps.includes(map)) {
                    return false;
                }

                return true;
            }
        });
    </script>
</dom-module>
